//! # Analytics Integration Example
//!
//! Demonstrates the integration between ExecutionManager and AnalyticsEngine.

use analytics_engine::analytics::{AnalyticsEvent, EventType};
use analytics_engine::{init_analytics, AnalyticsConfig};
use execution_manager::{ExecManagerConfig, ExecutionManager};
use std::sync::Arc;
use std::time::Duration;
use tokio::sync::mpsc;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Initialize logging (simplified for demo)
    println!("🔧 Initializing logging...");

    println!("🚀 Starting Analytics Integration Demo");

    // Create AnalyticsEngine
    let analytics_config = AnalyticsConfig::default();
    let _analytics = init_analytics(analytics_config).await?;

    // Create channel for analytics events
    let (analytics_sender, mut analytics_receiver) = mpsc::unbounded_channel::<AnalyticsEvent>();

    // Create ExecutionManager
    let exec_config = ExecManagerConfig::default();
    let account_service = Arc::new(account_service::AccountService::new(
        account_service::AccountServiceConfig::default()
    ).await?);
    let mut exec_manager = ExecutionManager::new(exec_config, account_service);

    // Connect AnalyticsEngine to ExecutionManager
    exec_manager.set_analytics_sender(analytics_sender);

    // Start analytics event processing with timeout
    let analytics_handle = tokio::spawn(async move {
        let mut event_count = 0;
        let timeout = Duration::from_secs(5); // 5 second timeout

        loop {
            match tokio::time::timeout(timeout, analytics_receiver.recv()).await {
                Ok(Some(event)) => {
                    event_count += 1;
                    println!(
                        "📊 Received analytics event #{}: {:?}",
                        event_count,
                        event.event_type()
                    );

                    // In a real implementation, we would process and store this event
                    match event.event_type() {
                        EventType::Performance => {
                            println!("  ⚡ Performance metrics received");
                        }
                        EventType::Business => {
                            println!("  💰 Business metrics received");
                        }
                        EventType::SystemHealth => {
                            println!("  🏥 System health metrics received");
                        }
                        EventType::Operational => {
                            println!("  🔧 Operational metrics received");
                        }
                    }
                }
                Ok(None) => {
                    println!("📊 Analytics channel closed. Total events received: {event_count}");
                    break;
                }
                Err(_) => {
                    println!(
                        "⏰ Analytics event timeout reached. Total events received: {event_count}"
                    );
                    break;
                }
            }
        }
        println!("📊 Analytics event processing completed. Total events: {event_count}");
    });

    // Simulate some trading activity
    println!("📈 Simulating trading activity...");

    // Register a symbol
    exec_manager.register_symbol(1); // Symbol ID 1

    // In a real implementation, we would:
    // 1. Create Whistle engines for symbols
    // 2. Process orders and generate events
    // 3. ExecutionManager would automatically convert and send analytics events

    // For demo purposes, let's simulate some events
    simulate_trading_activity(&mut exec_manager).await?;

    // Wait a bit for events to be processed
    tokio::time::sleep(Duration::from_millis(100)).await;

    // Shutdown
    println!("🛑 Shutting down...");
    // analytics_receiver is moved into the task, so we can't close it here
    // The task will naturally end when the channel is closed
    analytics_handle.await?;

    println!("✅ Analytics Integration Demo completed successfully!");

    Ok(())
}

async fn simulate_trading_activity(
    exec_manager: &mut ExecutionManager,
) -> Result<(), Box<dyn std::error::Error>> {
    println!("  📊 Analytics integration is ready!");
    println!("  🔄 ExecutionManager will automatically convert events to analytics format");
    println!("  📈 AnalyticsEngine will receive and process all trading metrics");

    // Get current stats
    let stats = exec_manager.get_stats();
    println!("  📊 Current ExecutionManager stats: {stats:?}");

    // Note: In a real implementation, events would be generated by Whistle engines
    // processing actual orders. For this demo, we're just showing the integration
    // is set up correctly. The ExecutionManager is ready to receive events from
    // Whistle and automatically convert them to analytics events.

    println!("  ✅ Integration setup complete - ready for real trading events!");

    Ok(())
}
